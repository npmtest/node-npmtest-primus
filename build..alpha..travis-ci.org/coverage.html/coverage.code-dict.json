{"/home/travis/build/npmtest/node-npmtest-primus/test.js":"/* istanbul instrument in package npmtest_primus */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-primus/lib.npmtest_primus.js":"/* istanbul instrument in package npmtest_primus */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_primus = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_primus = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-primus/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-primus && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_primus */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_primus\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_primus.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_primus.rollup.js'] =\n            local.assetsDict['/assets.npmtest_primus.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_primus.__dirname +\n                    '/lib.npmtest_primus.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-primus/primus/index.js":"'use strict';\n\nvar PrimusError = require('./errors').PrimusError\n  , EventEmitter = require('eventemitter3')\n  , Transformer = require('./transformer')\n  , log = require('diagnostics')('primus')\n  , Spark = require('./spark')\n  , fuse = require('fusing')\n  , fs = require('fs')\n  , vm = require('vm');\n\n/**\n * Primus is a universal wrapper for real-time frameworks that provides a common\n * interface for server and client interaction.\n *\n * @constructor\n * @param {HTTP.Server} server HTTP or HTTPS server instance.\n * @param {Object} options Configuration\n * @api public\n */\nfunction Primus(server, options) {\n  if (!(this instanceof Primus)) return new Primus(server, options);\n\n  this.fuse();\n\n  if ('object' !== typeof server) {\n    var message = 'The first argument of the constructor must be ' +\n      'an HTTP or HTTPS server instance';\n    throw new PrimusError(message, this);\n  }\n\n  options = options || {};\n  options.maxLength = options.maxLength || 10485760;  // Maximum allowed packet size.\n  options.transport = options.transport || {};        // Transformer specific options.\n  options.pingInterval = 'pingInterval' in options    // Heartbeat interval.\n    ? options.pingInterval\n    : 30000;\n\n  if ('timeout' in options) {\n    throw new PrimusError('The `timeout` option has been removed', this);\n  }\n\n  var primus = this\n    , key;\n\n  this.auth = options.authorization || null;  // Do we have an authorization handler.\n  this.connections = Object.create(null);     // Connection storage.\n  this.ark = Object.create(null);             // Plugin storage.\n  this.layers = [];                           // Middleware layers.\n  this.heartbeatInterval = null;              // The heartbeat interval.\n  this.transformer = null;                    // Reference to the real-time engine instance.\n  this.encoder = null;                        // Shorthand to the parser's encoder.\n  this.decoder = null;                        // Shorthand to the parser's decoder.\n  this.connected = 0;                         // Connection counter.\n  this.whitelist = [];                        // Forwarded-for white listing.\n  this.options = options;                     // The configuration.\n  this.transformers = {                       // Message transformers.\n    outgoing: [],\n    incoming: []\n  };\n\n  this.server = server;\n  this.pathname = 'string' === typeof options.pathname\n    ? options.pathname.charAt(0) !== '/'\n      ? '/'+ options.pathname\n      : options.pathname\n    : '/primus';\n\n  //\n  // Create a specification file with the information that people might need to\n  // connect to the server.\n  //\n  this.spec = {\n    pingInterval: options.pingInterval,\n    pathname: this.pathname,\n    version: this.version\n  };\n\n  //\n  // Create a pre-bound Spark constructor. Doing a Spark.bind(Spark, this) doesn't\n  // work as we cannot extend the constructor of it anymore. The added benefit of\n  // approach listed below is that the prototype extensions are only applied to\n  // the Spark of this Primus instance.\n  //\n  this.Spark = function Sparky(headers, address, query, id, request) {\n    Spark.call(this, primus, headers, address, query, id, request);\n  };\n\n  this.Spark.prototype = Object.create(Spark.prototype, {\n    constructor: {\n      configurable: true,\n      value: this.Spark,\n      writable: true\n    },\n    __initialise: {\n      value: Spark.prototype.__initialise.slice(),\n      configurable: true,\n      writable: true\n    }\n  });\n\n  //\n  // Copy over the original Spark static properties and methods so readable and\n  // writable can also be used.\n  //\n  for (key in Spark) {\n    this.Spark[key] = Spark[key];\n  }\n\n  this.parsers(options.parser);\n  this.initialise(options.transformer, options);\n\n  //\n  // If the plugins are supplied through the options, also initialise them.\n  // This also allows us to use plugins when creating a client constructor\n  // with the `Primus.createSocket({})` method.\n  //\n  if ('string' === typeof options.plugin) {\n    options.plugin.split(/[, ]+/).forEach(function register(name) {\n      primus.plugin(name, name);\n    });\n  } else if ('object' === typeof options.plugin) {\n    for (key in options.plugin) {\n      this.plugin(key, options.plugin[key]);\n    }\n  }\n\n  //\n  // - Cluster node 0.10 lets the Operating System decide to which worker a request\n  //   goes. This can result in a not even distribution where some workers are\n  //   used at 10% while others at 90%. In addition to that the load balancing\n  //   isn't sticky.\n  //\n  // - Cluster node 0.12 implements a custom round robin algorithm. This solves the\n  //   not even distribution of work but it does not address our sticky session\n  //   requirement.\n  //\n  // Projects like `sticky-session` attempt to implement sticky sessions but they\n  // are using `net` server instead of a HTTP server in combination with the\n  // remoteAddress of the connection to load balance. This does not work when you\n  // address your servers behind a load balancer as the IP is set to the load\n  // balancer, not the connecting clients. All in all, it only causes more\n  // scalability problems. So we've opted-in to warn users about the\n  // risks of using Primus in a cluster.\n  //\n  if (!options.iknowclusterwillbreakconnections && require('cluster').isWorker) [\n    '',\n    'The `cluster` module does not implement sticky sessions. Learn more about',\n    'this issue at:',\n    '',\n    'http://github.com/primus/primus#can-i-use-cluster',\n    ''\n  ].forEach(function warn(line) {\n    console.error('Primus: '+ line);\n  });\n}\n\n//\n// Fuse and spice-up the Primus prototype with EventEmitter and predefine\n// awesomeness.\n//\nfuse(Primus, EventEmitter);\n\n//\n// Lazy read the primus.js JavaScript client.\n//\nObject.defineProperty(Primus.prototype, 'client', {\n  get: function read() {\n    if (!read.primus) {\n      read.primus = fs.readFileSync(__dirname + '/dist/primus.js', 'utf-8');\n    }\n\n    return read.primus;\n  }\n});\n\n//\n// Lazy compile the primus.js JavaScript client for Node.js\n//\nObject.defineProperty(Primus.prototype, 'Socket', {\n  get: function () {\n    const sandbox = Object.keys(global).reduce((acc, key) => {\n      if (key !== 'global' && key !== 'require') acc[key] = global[key];\n      return acc;\n    }, {\n      __dirname: process.cwd(),\n      __filename: 'primus.js',\n      require: require,\n\n      //\n      // The following globals are introduced so libraries that use `instanceof`\n      // checks for type checking do not fail as the code is run in a new\n      // context.\n      //\n      Uint8Array: Uint8Array,\n      Object: Object,\n      RegExp: RegExp,\n      Array: Array,\n      Error: Error,\n      Date: Date\n    });\n\n    vm.runInNewContext(this.library(true), sandbox, { filename: 'primus.js' });\n    return sandbox.Primus;\n  }\n});\n\n//\n// Expose the current version number.\n//\nPrimus.prototype.version = require('./package.json').version;\n\n//\n// A list of supported transformers and the required Node.js modules.\n//\nPrimus.transformers = require('./transformers.json');\nPrimus.parsers = require('./parsers.json');\n\n/**\n * Simple function to output common errors.\n *\n * @param {String} what What is missing.\n * @param {Object} where Either Primus.parsers or Primus.transformers.\n * @returns {Object}\n * @api private\n */\nPrimus.readable('is', function is(what, where) {\n  var missing = Primus.parsers !== where\n      ? 'transformer'\n      : 'parser'\n    , dependency = where[what];\n\n  return {\n    missing: function write() {\n      console.error('Primus:');\n      console.error('Primus: Missing required npm dependency for '+ what);\n      console.error('Primus: Please run the following command and try again:');\n      console.error('Primus:');\n      console.error('Primus:   npm install --save %s', dependency.server);\n      console.error('Primus:');\n\n      return 'Missing dependencies for '+ missing +': \"'+ what + '\"';\n    },\n\n    unknown: function write() {\n      console.error('Primus:');\n      console.error('Primus: Unsupported %s: \"%s\"', missing, what);\n      console.error('Primus: We only support the following %ss:', missing);\n      console.error('Primus:');\n      console.error('Primus:   %s', Object.keys(where).join(', '));\n      console.error('Primus:');\n\n      return 'Unsupported '+ missing +': \"'+ what +'\"';\n    }\n  };\n});\n\n/**\n * Initialise the real-time engine that was chosen.\n *\n * @param {Mixed} Transformer The name of the transformer or a constructor;\n * @param {Object} options Options.\n * @api private\n */\nPrimus.readable('initialise', function initialise(Transformer, options) {\n  Transformer = Transformer || 'websockets';\n\n  var primus = this\n    , transformer;\n\n  if ('string' === typeof Transformer) {\n    log('transformer `%s` is a string, attempting to resolve location', Transformer);\n    Transformer = transformer = Transformer.toLowerCase();\n    this.spec.transformer = transformer;\n\n    //\n    // This is a unknown transformer, it could be people made a typo.\n    //\n    if (!(Transformer in Primus.transformers)) {\n      log('the supplied transformer %s is not supported, please use %s', transformer, Primus.transformers);\n      throw new PrimusError(this.is(Transformer, Primus.transformers).unknown(), this);\n    }\n\n    try {\n      Transformer = require('./transformers/'+ transformer);\n      this.transformer = new Transformer(this);\n    } catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND') {\n        log('the supplied transformer `%s` is missing', transformer);\n        throw new PrimusError(this.is(transformer, Primus.transformers).missing(), this);\n      } else {\n        log(e);\n        throw e;\n      }\n    }\n  } else {\n    log('received a custom transformer');\n    this.spec.transformer = 'custom';\n  }\n\n  if ('function' !== typeof Transformer) {\n    throw new PrimusError('The given transformer is not a constructor', this);\n  }\n\n  this.transformer = this.transformer || new Transformer(this);\n\n  this.on('connection', function connection(stream) {\n    this.connected++;\n    this.connections[stream.id] = stream;\n\n    log('connection: %s currently serving %d concurrent', stream.id, this.connected);\n  });\n\n  this.on('disconnection', function disconnected(stream) {\n    this.connected--;\n    delete this.connections[stream.id];\n\n    log('disconnection: %s currently serving %d concurrent', stream.id, this.connected);\n  });\n\n  //\n  // Add our default middleware layers.\n  //\n  this.use('forwarded', require('./middleware/forwarded'));\n  this.use('cors', require('./middleware/access-control'));\n  this.use('primus.js', require('./middleware/primus'));\n  this.use('spec', require('./middleware/spec'));\n  this.use('x-xss', require('./middleware/xss'));\n  this.use('no-cache', require('./middleware/no-cache'));\n  this.use('authorization', require('./middleware/authorization'));\n\n  //\n  // Set the heartbeat interval.\n  //\n  if (options.pingInterval) {\n    this.heartbeatInterval = setInterval(\n      this.heartbeat.bind(this),\n      options.pingInterval\n    );\n  }\n\n  //\n  // Emit the initialised event after the next tick so we have some time to\n  // attach listeners.\n  //\n  process.nextTick(function tock() {\n    primus.emit('initialised', primus.transformer, primus.parser, options);\n  });\n});\n\n/**\n * Add a new authorization handler.\n *\n * @param {Function} auth The authorization handler.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('authorize', function authorize(auth) {\n  if ('function' !== typeof auth) {\n    throw new PrimusError('Authorize only accepts functions', this);\n  }\n\n  if (auth.length < 2) {\n    throw new PrimusError('Authorize function requires more arguments', this);\n  }\n\n  log('setting an authorization function');\n  this.auth = auth;\n  return this;\n});\n\n/**\n * Iterate over the connections.\n *\n * @param {Function} fn The function that is called every iteration.\n * @param {Function} done Optional callback, if you want to iterate asynchronously.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('forEach', function forEach(fn, done) {\n  if (!done) {\n    for (var id in this.connections) {\n      if (fn(this.spark(id), id, this.connections) === false) break;\n    }\n\n    return this;\n  }\n\n  var ids = Object.keys(this.connections)\n    , primus = this;\n\n  log('iterating over %d connections', ids.length);\n\n  function pushId(spark) {\n    ids.push(spark.id);\n  }\n\n  //\n  // We are going to iterate through the connections asynchronously so\n  // we should handle new connections as they come in.\n  //\n  primus.on('connection', pushId);\n\n  (function iterate() {\n    var id = ids.shift()\n      , spark;\n\n    if (!id) {\n      primus.removeListener('connection', pushId);\n      return done();\n    }\n\n    spark = primus.spark(id);\n\n    //\n    // The connection may have already been closed.\n    //\n    if (!spark) return iterate();\n\n    fn(spark, function next(err, forward) {\n      if (err || forward === false) {\n        primus.removeListener('connection', pushId);\n        return done(err);\n      }\n\n      iterate();\n    });\n  }());\n\n  return this;\n});\n\n/**\n * Send a ping packet to all clients to ensure that they are still connected.\n *\n * @returns {Primus}\n * @api private\n */\nPrimus.readable('heartbeat', function heartbeat() {\n  this.forEach(function forEach(spark) {\n    spark.heartbeat();\n  });\n\n  return this;\n});\n\n/**\n * Broadcast the message to all connections.\n *\n * @param {Mixed} data The data you want to send.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('write', function write(data) {\n  this.forEach(function forEach(spark) {\n    spark.write(data);\n  });\n\n  return this;\n});\n\n/**\n * Install message parsers.\n *\n * @param {Mixed} parser Parse name or parser Object.\n * @returns {Primus}\n * @api private\n */\nPrimus.readable('parsers', function parsers(parser) {\n  parser = parser || 'json';\n\n  if ('string' === typeof parser) {\n    log('transformer `%s` is a string, attempting to resolve location', parser);\n    parser = parser.toLowerCase();\n    this.spec.parser = parser;\n\n    //\n    // This is a unknown parser, it could be people made a typo.\n    //\n    if (!(parser in Primus.parsers)) {\n      log('the supplied parser `%s` is not supported please use %s', parser, Primus.parsers);\n      throw new PrimusError(this.is(parser, Primus.parsers).unknown(), this);\n    }\n\n    try { parser = require('./parsers/'+ parser); }\n    catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND') {\n        log('the supplied parser `%s` is missing', parser);\n        throw new PrimusError(this.is(parser, Primus.parsers).missing(), this);\n      } else {\n        log(e);\n        throw e;\n      }\n    }\n  } else {\n    this.spec.parser = 'custom';\n  }\n\n  if ('object' !== typeof parser) {\n    throw new PrimusError('The given parser is not an Object', this);\n  }\n\n  this.encoder = parser.encoder;\n  this.decoder = parser.decoder;\n  this.parser = parser;\n\n  return this;\n});\n\n/**\n * Register a new message transformer. This allows you to easily manipulate incoming\n * and outgoing data which is particularity handy for plugins that want to send\n * meta data together with the messages.\n *\n * @param {String} type Incoming or outgoing\n * @param {Function} fn A new message transformer.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('transform', function transform(type, fn) {\n  if (!(type in this.transformers)) {\n    throw new PrimusError('Invalid transformer type', this);\n  }\n\n  if (~this.transformers[type].indexOf(fn)) {\n    log('the %s message transformer already exists, not adding it', type);\n    return this;\n  }\n\n  this.transformers[type].push(fn);\n  return this;\n});\n\n/**\n * Gets a spark by its id.\n *\n * @param {String} id The spark's id.\n * @returns {Spark}\n * @api private\n */\nPrimus.readable('spark', function spark(id) {\n  return this.connections[id];\n});\n\n/**\n * Generate a client library.\n *\n * @param {Boolean} nodejs Don't include the library, as we're running on Node.js.\n * @returns {String} The client library.\n * @api public\n */\nPrimus.readable('library', function compile(nodejs) {\n  var library = [ !nodejs ? this.transformer.library : null ]\n    , global = this.options.global || 'Primus'\n    , parser = this.parser.library || ''\n    , client = this.client;\n\n  //\n  // Add a simple export wrapper so it can be used as Node.js, AMD or browser\n  // client.\n  //\n  client = [\n    '(function UMDish(name, context, definition, plugins) {',\n    '  context[name] = definition.call(context);',\n    '  for (var i = 0; i < plugins.length; i++) {',\n    '    plugins[i](context[name])',\n    '  }',\n    '  if (typeof module !== \"undefined\" && module.exports) {',\n    '    module.exports = context[name];',\n    '  } else if (typeof define === \"function\" && define.amd) {',\n    '    define(function reference() { return context[name]; });',\n    '  }',\n    '})(\"'+ global +'\", this || {}, function wrapper() {',\n    '  var define, module, exports',\n    '    , Primus = '+ client.slice(client.indexOf('return ') + 7, -4) +';',\n    ''\n  ].join('\\n');\n\n  //\n  // Replace some basic content.\n  //\n  client = client\n    .replace('null; // @import {primus::pathname}', '\"'+ this.pathname.toString() +'\"')\n    .replace('null; // @import {primus::version}', '\"'+ this.version +'\"')\n    .replace('null; // @import {primus::client}', this.transformer.client.toString())\n    .replace('null; // @import {primus::auth}', (!!this.auth).toString())\n    .replace('null; // @import {primus::encoder}', this.encoder.toString())\n    .replace('null; // @import {primus::decoder}', this.decoder.toString());\n\n  //\n  // As we're given a `pingInterval` value on the server side, we need to update\n  // the `pingTimeout` on the client.\n  //\n  if (this.options.pingInterval) {\n    const value = this.options.pingInterval + Math.round(this.options.pingInterval / 2);\n\n    log('updating the default value of the client `pingTimeout` option');\n    client = client.replace(\n      'options.pingTimeout : 45e3;',\n      `options.pingTimeout : ${value};`\n    );\n  } else {\n    log('setting the default value of the client `pingTimeout` option to `false`');\n    client = client.replace(\n      'options.pingTimeout : 45e3;',\n      'options.pingTimeout : false;'\n    );\n  }\n\n  //\n  // Add the parser inside the closure, to prevent global leaking.\n  //\n  if (parser && parser.length) {\n    log('adding parser to the client file');\n    client += parser;\n  }\n\n  //\n  // Iterate over the parsers, and register the client side plugins. If there's\n  // a library bundled, add it the library array as there were some issues with\n  // frameworks that get included in module wrapper as it forces strict mode.\n  //\n  var name, plugin;\n\n  for (name in this.ark) {\n    plugin = this.ark[name];\n    name = JSON.stringify(name);\n\n    if (plugin.library) {\n      log('adding the library of the %s plugin to the client file', name);\n      library.push(plugin.library);\n    }\n\n    if (!plugin.client) continue;\n\n    log('adding the client code of the %s plugin to the client file', name);\n    client += 'Primus.prototype.ark['+ name +'] = '+ plugin.client.toString() +';\\n';\n  }\n\n  //\n  // Close the export wrapper and return the client. If we need to add\n  // a library, we should add them after we've created our closure and module\n  // exports. Some libraries seem to fail hard once they are wrapped in our\n  // closure so I'll rather expose a global variable instead of having to monkey\n  // patch too much code.\n  //\n  return client + [\n    '  return Primus;',\n    '},',\n    '['\n  ].concat(library.filter(Boolean).map(function expose(library) {\n    return [\n      'function (Primus) {',\n      library,\n      '}'\n    ].join('\\n');\n  }).join(',\\n'))\n  .concat(']);')\n  .join('\\n');\n});\n\n/**\n * Save the library to disk.\n *\n * @param {String} dir The location that we need to save the library.\n * @param {function} fn Optional callback, if you want an async save.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('save', function save(path, fn) {\n  if (!fn) fs.writeFileSync(path, this.library(), 'utf-8');\n  else fs.writeFile(path, this.library(), 'utf-8', fn);\n\n  return this;\n});\n\n/**\n * Register a new Primus plugin.\n *\n * ```js\n * primus.plugin('ack', {\n *   //\n *   // Only ran on the server.\n *   //\n *   server: function (primus, options) {\n *      // do stuff\n *   },\n *\n *   //\n *   // Runs on the client, it's automatically bundled.\n *   //\n *   client: function (primus, options) {\n *      // do client stuff\n *   },\n *\n *   //\n *   // Optional library that needs to be bundled on the client (should be a string)\n *   //\n *   library: ''\n * });\n * ```\n *\n * @param {String} name The name of the plugin.\n * @param {Object} energon The plugin that contains client and server extensions.\n * @returns {Mixed}\n * @api public\n */\nPrimus.readable('plugin', function plugin(name, energon) {\n  if (!name) return this.ark;\n\n  if (!energon) {\n    if ('string' === typeof name) return this.ark[name];\n    if ('object' === typeof name) {\n      energon = name;\n      name = energon.name;\n    }\n  }\n\n  if ('string' !== typeof name || !name) {\n    throw new PrimusError('Plugin name must be a non empty string', this);\n  }\n\n  if ('string' === typeof energon) {\n    log('plugin was passed as a string, attempting to require %s', energon);\n    energon = require(energon);\n  }\n\n  //\n  // Plugin accepts an object or a function only.\n  //\n  if (!/^(object|function)$/.test(typeof energon)) {\n    throw new PrimusError('Plugin should be an object or function', this);\n  }\n\n  //\n  // Plugin require a client, server or both to be specified in the object.\n  //\n  if (!energon.server && !energon.client) {\n    throw new PrimusError('Plugin is missing a client or server function', this);\n  }\n\n  //\n  // Don't allow duplicate plugins or plugin override as this is most likely\n  // unintentional.\n  //\n  if (name in this.ark) {\n    throw new PrimusError('Plugin name already defined', this);\n  }\n\n  log('adding %s as new plugin', name);\n  this.ark[name] = energon;\n  this.emit('plugin', name, energon);\n\n  if (!energon.server) return this;\n\n  log('calling the %s plugin\\'s server code', name);\n  energon.server.call(this, this, this.options);\n\n  return this;\n});\n\n/**\n * Remove plugin from the ark.\n *\n * @param {String} name Name of the plugin we need to remove from the ark.\n * @returns {Boolean} Successful removal of the plugin.\n * @api public\n */\nPrimus.readable('plugout', function plugout(name) {\n  if (!(name in this.ark)) return false;\n\n  this.emit('plugout', name, this.ark[name]);\n  delete this.ark[name];\n\n  return true;\n});\n\n/**\n * Add a new middleware layer. If no middleware name has been provided we will\n * attempt to take the name of the supplied function. If that fails, well fuck,\n * just random id it.\n *\n * @param {String} name The name of the middleware.\n * @param {Function} fn The middleware that's called each time.\n * @param {Object} options Middleware configuration.\n * @param {Number} level 0 based optional index for the middleware.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('use', function use(name, fn, options, level) {\n  if ('function' === typeof name) {\n    level = options;\n    options = fn;\n    fn = name;\n    name = fn.name || 'pid_'+ Date.now();\n  }\n\n  if (!level && 'number' === typeof options) {\n    level = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  //\n  // No or only 1 argument means that we need to initialise the middleware, this\n  // is a special initialisation process where we pass in a reference to the\n  // initialised Primus instance so a pre-compiling process can be done.\n  //\n  if (fn.length < 2) {\n    log('automatically configuring middleware `%s`', name);\n    fn = fn.call(this, options);\n  }\n\n  //\n  // Make sure that we have a function that takes at least 2 arguments.\n  //\n  if ('function' !== typeof fn || fn.length < 2) {\n    throw new PrimusError('Middleware should be a function that accepts at least 2 args');\n  }\n\n  var layer = {\n    length: fn.length,                // Amount of arguments indicates if it's async.\n    enabled: true,                    // Middleware is enabled by default.\n    name: name,                       // Used for lookups.\n    fn: fn                            // The actual middleware.\n  }, index = this.indexOfLayer(name);\n\n  //\n  // Override middleware layer if we already have a middleware layer with\n  // exactly the same name.\n  //\n  if (!~index) {\n    if (level >= 0 && level < this.layers.length) {\n      log('adding middleware `%s` to the supplied index at %d', name, level);\n      this.layers.splice(level, 0, layer);\n    } else {\n      this.layers.push(layer);\n    }\n  } else {\n    this.layers[index] = layer;\n  }\n\n  return this;\n});\n\n/**\n * Remove a middleware layer from the stack.\n *\n * @param {String} name The name of the middleware.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('remove', function remove(name) {\n  var index = this.indexOfLayer(name);\n\n  if (~index) {\n    log('removing middleware `%s`', name);\n    this.layers.splice(index, 1);\n  }\n\n  return this;\n});\n\n/**\n * Enable a given middleware layer.\n *\n * @param {String} name The name of the middleware.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('enable', function enable(name) {\n  var index = this.indexOfLayer(name);\n\n  if (~index) {\n    log('enabling middleware `%s`', name);\n    this.layers[index].enabled = true;\n  }\n  return this;\n});\n\n/**\n * Disable a given middleware layer.\n *\n * @param {String} name The name of the middleware.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('disable', function disable(name) {\n  var index = this.indexOfLayer(name);\n\n  if (~index) {\n    log('disabling middleware `%s`', name);\n    this.layers[index].enabled = false;\n  }\n\n  return this;\n});\n\n/**\n * Find the index of a given middleware layer by name.\n *\n * @param {String} name The name of the layer.\n * @returns {Number}\n * @api private\n */\nPrimus.readable('indexOfLayer', function indexOfLayer(name) {\n  for (var i = 0, length = this.layers.length; i < length; i++) {\n    if (this.layers[i].name === name) return i;\n  }\n\n  return -1;\n});\n\n/**\n * Destroy the created Primus instance.\n *\n * Options:\n * - close (boolean) Close the given server.\n * - reconnect (boolean) Trigger a client-side reconnect.\n * - timeout (number) Close all active connections after x milliseconds.\n *\n * @param {Object} options Destruction instructions.\n * @param {Function} fn Callback.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('destroy', function destroy(options, fn) {\n  if ('function' === typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  options = options || {};\n  if (options.reconnect) options.close = true;\n\n  var primus = this;\n\n  clearInterval(primus.heartbeatInterval);\n\n  setTimeout(function close() {\n    var transformer = primus.transformer;\n\n    //\n    // Ensure that the transformer receives the `close` event only once.\n    //\n    if (transformer) transformer.ultron.destroy();\n\n    //\n    // Close the connections that are left open.\n    //\n    primus.forEach(function shutdown(spark) {\n      spark.end(undefined, { reconnect: options.reconnect });\n    });\n\n    if (options.close !== false) {\n      //\n      // Closing a server that isn't started yet would throw an error.\n      //\n      try {\n        primus.server.close(function closed() {\n          primus.close(options, fn);\n        });\n        return;\n      }\n      catch (e) {}\n    }\n\n    primus.close(options, fn);\n  }, +options.timeout || 0);\n\n  return this;\n});\n\n/**\n * Free resources after emitting a final `close` event.\n *\n * @param {Object} options Destruction instructions.\n * @param {Function} fn Callback.\n * @returns {Primus}\n * @api private\n */\nPrimus.readable('close', function close(options, fn) {\n  var primus = this;\n  //\n  // Emit a final `close` event before removing all the listeners\n  // from all the event emitters.\n  //\n  primus.asyncemit('close', options, function done(err) {\n    if (err) {\n      if (fn) return fn(err);\n      throw err;\n    }\n\n    var transformer = primus.transformer\n      , server = primus.server;\n\n    //\n    // If we don't have a server we are most likely destroying an already\n    // destroyed Primus instance.\n    //\n    if (!server) return fn && fn();\n\n    server.removeAllListeners('request');\n    server.removeAllListeners('upgrade');\n\n    //\n    // Re-add the original listeners so that the server can be used again.\n    //\n    transformer.listeners('previous::request').forEach(function add(listener) {\n      server.on('request', listener);\n    });\n    transformer.listeners('previous::upgrade').forEach(function add(listener) {\n      server.on('upgrade', listener);\n    });\n\n    transformer.emit('close', options);\n    transformer.removeAllListeners();\n\n    primus.removeAllListeners();\n\n    //\n    // Null some potentially heavy objects to free some more memory instantly.\n    //\n    primus.transformers.outgoing.length = primus.transformers.incoming.length = 0;\n    primus.transformer = primus.encoder = primus.decoder = primus.server = null;\n    primus.connected = 0;\n\n    primus.connections = Object.create(null);\n    primus.ark = Object.create(null);\n\n    if (fn) fn();\n  });\n\n  return this;\n});\n\n/**\n * Async emit an event. We make a really broad assumption here and that is they\n * have the same amount of arguments as the supplied arguments (excluding the\n * event name).\n *\n * @returns {Primus}\n * @api private\n */\nPrimus.readable('asyncemit', require('asyncemit'));\n\n//\n// Alias for destroy.\n//\nPrimus.readable('end', Primus.prototype.destroy);\n\n/**\n * Checks if the given event is an emitted event by Primus.\n *\n * @param {String} evt The event name.\n * @returns {Boolean}\n * @api public\n */\nPrimus.readable('reserved', function reserved(evt) {\n  return (/^(incoming|outgoing)::/).test(evt)\n  || evt in reserved.events;\n});\n\n/**\n * The actual events that are used by Primus.\n *\n * @type {Object}\n * @api public\n */\nPrimus.prototype.reserved.events = {\n  'disconnection': 1,\n  'initialised': 1,\n  'connection': 1,\n  'plugout': 1,\n  'plugin': 1,\n  'close': 1,\n  'log': 1\n};\n\n/**\n * Add a createSocket interface so we can create a Server client with the\n * specified `transformer` and `parser`.\n *\n * ```js\n * var Socket = Primus.createSocket({ transformer: transformer, parser: parser })\n *   , socket = new Socket(url);\n * ```\n *\n * @param {Object} options The transformer / parser we need.\n * @returns {Socket}\n * @api public\n */\nPrimus.createSocket = function createSocket(options) {\n  options = options || {};\n\n  var primus = new Primus(new EventEmitter(), options);\n  return primus.Socket;\n};\n\n/**\n * Create a new Primus server.\n *\n * @param {Function} fn Request listener.\n * @param {Object} options Configuration.\n * @returns {Pipe}\n * @api public\n */\nPrimus.createServer = function createServer(fn, options) {\n  if ('object' === typeof fn) {\n    options = fn;\n    fn = null;\n  }\n\n  options = options || {};\n\n  var server = require('create-server')(Primus.prototype.merge.call(Primus, {\n    http: function warn() {\n      if (!options.iknowhttpsisbetter) [\n        '',\n        'We\\'ve detected that you\\'re using a HTTP instead of a HTTPS server.',\n        'Please be aware that real-time connections have less chance of being blocked',\n        'by firewalls and anti-virus scanners if they are encrypted (using SSL). If',\n        'you run your server behind a reverse and HTTPS terminating proxy ignore',\n        'this message, if not, you\\'ve been warned.',\n        ''\n      ].forEach(function each(line) {\n        console.log('primus: '+ line);\n      });\n    }\n  }, options));\n\n  //\n  // Now that we've got a server, we can setup the Primus and start listening.\n  //\n  var application = new Primus(server, options);\n\n  if (fn) application.on('connection', fn);\n  return application;\n};\n\n//\n// Expose the constructors of our Spark and Transformer so it can be extended by\n// a third party if needed.\n//\nPrimus.Transformer = Transformer;\nPrimus.Spark = Spark;\n\n//\n// Expose the module.\n//\nmodule.exports = Primus;\n","/home/travis/build/npmtest/node-npmtest-primus/primus/errors.js":"'use strict';\n\nvar util = require('util');\n\n/**\n * Generic Primus error.\n *\n * @constructor\n * @param {String} message The reason for the error\n * @param {EventEmitter} logger Optional EventEmitter to emit a `log` event on.\n * @api public\n */\nfunction PrimusError(message, logger) {\n  Error.captureStackTrace(this, this.constructor);\n\n  this.message = message;\n  this.name = this.constructor.name;\n\n  if (logger) {\n    logger.emit('log', 'error', this);\n  }\n}\n\nutil.inherits(PrimusError, Error);\n\n/**\n * There was an error while parsing incoming or outgoing data.\n *\n * @param {String} message The reason for the error.\n * @param {Spark} spark The spark that caused the error.\n * @api public\n */\nfunction ParserError(message, spark) {\n  Error.captureStackTrace(this, this.constructor);\n\n  this.message = message;\n  this.name = this.constructor.name;\n\n  if (spark) {\n    if (spark.listeners('error').length) spark.emit('error', this);\n    spark.primus.emit('log', 'error', this);\n  }\n}\n\nutil.inherits(ParserError, Error);\n\n//\n// Expose our custom events.\n//\nexports.PrimusError = PrimusError;\nexports.ParserError = ParserError;\n","/home/travis/build/npmtest/node-npmtest-primus/primus/transformer.js":"'use strict';\n\nvar log = require('diagnostics')('primus:transformer')\n  , middlewareError = require('./middleware/error')\n  , url = require('url').parse\n  , Ultron = require('ultron')\n  , fuse = require('fusing');\n\n/**\n * Transformer skeleton\n *\n * @constructor\n * @param {Primus} primus Reference to the Primus instance.\n * @api public\n */\nfunction Transformer(primus) {\n  this.fuse();\n\n  this.ultron = new Ultron(primus.server);  // Handles listeners with ease.\n  this.Spark = primus.Spark;                // Reference to the Spark constructor.\n  this.primus = primus;                     // Reference to the Primus instance.\n  this.service = null;                      // Stores the real-time service.\n\n  this.initialise();\n}\n\nfuse(Transformer, require('eventemitter3'));\n\n//\n// Simple logger shortcut.\n//\nObject.defineProperty(Transformer.prototype, 'logger', {\n  get: function logger() {\n    return {\n      error: this.primus.emits('log', 'error'), // Log error <line>.\n      warn:  this.primus.emits('log', 'warn'),  // Log warn <line>.\n      info:  this.primus.emits('log', 'info'),  // Log info <line>.\n      debug: this.primus.emits('log', 'debug'), // Log debug <line>.\n      log:   this.primus.emits('log', 'log'),   // Log log <line>.\n      plain: this.primus.emits('log', 'log')    // Log log <line>.\n    };\n  }\n});\n\n/**\n * Create the server and attach the appropriate event listeners.\n *\n * @api private\n */\nTransformer.readable('initialise', function initialise() {\n  if (this.server) this.server();\n\n  var server = this.primus.server\n    , transformer = this;\n\n  server.listeners('request').forEach(function each(fn) {\n    log('found existing request handlers on the HTTP server, moving Primus as first');\n    transformer.on('previous::request', fn, server);\n  });\n\n  server.listeners('upgrade').forEach(function each(fn) {\n    log('found existing upgrade handlers on the HTTP server, moving Primus as first');\n    transformer.on('previous::upgrade', fn, server);\n  });\n\n  //\n  // Remove the old listeners as we want to be the first request handler for all\n  // events.\n  //\n  server.removeAllListeners('request');\n  server.removeAllListeners('upgrade');\n\n  //\n  // Emit a close event.\n  //\n  this.ultron.on('close', function close() {\n    log('the HTTP server is closing');\n    transformer.emit('close');\n  });\n\n  //\n  // Start listening for incoming requests if we have a listener assigned to us.\n  //\n  if (this.listeners('request').length || this.listeners('previous::request').length) {\n    server.on('request', this.request.bind(this));\n  }\n\n  if (this.listeners('upgrade').length || this.listeners('previous::upgrade').length) {\n    server.on('upgrade', this.upgrade.bind(this));\n  }\n});\n\n/**\n * Iterate all the middleware layers that we're set on our Primus instance.\n *\n * @param {String} type Either `http` or `upgrade`\n * @param {Request} req HTTP request.\n * @param {Response} res HTTP response.\n * @param {Function} next Continuation callback.\n * @api private\n */\nTransformer.readable('forEach', function forEach(type, req, res, next) {\n  var transformer = this\n    , layers = transformer.primus.layers\n    , primus = transformer.primus;\n\n  req.query = req.uri.query || {};\n\n  //\n  // Add some silly HTTP properties for connect.js compatibility.\n  //\n  req.originalUrl = req.url;\n\n  if (!layers.length) {\n    next();\n    return transformer;\n  }\n\n  //\n  // Async or sync call the middleware layer.\n  //\n  (function iterate(index) {\n    var layer = layers[index++];\n\n    if (!layer) return next();\n    if (!layer.enabled || layer.fn[type] === false) return iterate(index);\n\n    if (layer.length === 2) {\n      log('executing middleware (%s) synchronously', layer.name);\n\n      if (layer.fn.call(primus, req, res)) return;\n      return iterate(index);\n    }\n\n    log('executing middleware (%s) asynchronously', layer.name);\n    layer.fn.call(primus, req, res, function done(err) {\n      if (err) return middlewareError(err, req, res);\n\n      iterate(index);\n    });\n  }(0));\n\n  return transformer;\n});\n\n/**\n * Start listening for incoming requests and check if we need to forward them to\n * the transformers.\n *\n * @param {Request} req HTTP request.\n * @param {Response} res HTTP response.\n * @api private\n */\nTransformer.readable('request', function request(req, res) {\n  if (!this.test(req)) return this.emit('previous::request', req, res);\n\n  req.headers['primus::req::backup'] = req;\n  res.once('end', function gc() {\n    delete req.headers['primus::req::backup'];\n  });\n\n  //\n  // I want to see you're face when you're looking at the lines of code above\n  // while you think, WTF what is this shit, you mad bro!? Let me take a moment\n  // to explain this mad and sadness.\n  //\n  // There are some real-time transformers that do not give us access to the\n  // HTTP request that initiated their `socket` connection. They only give us\n  // access to the information that they think is useful, we're greedy, we want\n  // everything and let developers decide what they want to use instead and\n  // therefor want to expose this HTTP request on our `spark` object.\n  //\n  // The reason it's added to the headers is because it's currently the only\n  // field that is accessible through all transformers.\n  //\n\n  log('handling HTTP request for url: %s', req.url);\n  this.forEach('http', req, res, this.emits('request', req, res));\n});\n\n/**\n * Starting listening for incoming upgrade requests and check if we need to\n * forward them to the transformers.\n *\n * @param {Request} req HTTP request.\n * @param {Socket} socket Socket.\n * @param {Buffer} head Buffered data.\n * @api private\n */\nTransformer.readable('upgrade', function upgrade(req, socket, head) {\n  if (!this.test(req)) return this.emit('previous::upgrade', req, socket, head);\n\n  //\n  // See Transformer#request for an explanation of this madness.\n  //\n  req.headers['primus::req::backup'] = req;\n  socket.once('end', function gc() {\n    delete req.headers['primus::req::backup'];\n  });\n\n  log('handling HTTP upgrade for url: %s', req.url);\n  this.forEach('upgrade', req, socket, this.emits('upgrade', req, socket, head));\n});\n\n/**\n * Check if we should accept this request.\n *\n * @param {Request} req HTTP Request.\n * @returns {Boolean} Do we need to accept this request.\n * @api private\n */\nTransformer.readable('test', function test(req) {\n  req.uri = url(req.url, true);\n\n  var pathname = req.uri.pathname || '/'\n    , route = this.primus.pathname;\n\n  return pathname.slice(0, route.length) === route;\n});\n\n//\n// Expose the transformer's skeleton.\n//\nmodule.exports = Transformer;\n","/home/travis/build/npmtest/node-npmtest-primus/primus/middleware/error.js":"'use strict';\n\n/**\n * WARNING: this middleware is only used internally and does not follow the\n * pattern of the other middleware. You should not use it.\n *\n * Handle async middleware errors.\n *\n * @param {Error} err Error returned by the middleware.\n * @param {Request} req HTTP request.\n * @param {Response} res HTTP response.\n * @api private\n */\nmodule.exports = function error(err, req, res) {\n  var message = JSON.stringify({ error: err.message || err })\n    , length = Buffer.byteLength(message)\n    , code = err.statusCode || 500;\n\n  //\n  // As in the authorization middleware we need to handle two cases here:\n  // regular HTTP requests and upgrade requests.\n  //\n  if (res.setHeader) {\n    res.statusCode = code;\n    res.setHeader('Content-Type', 'application/json');\n    res.setHeader('Content-Length', length);\n\n    return res.end(message);\n  }\n\n  res.write('HTTP/'+ req.httpVersion +' ');\n  res.write(code +' '+ require('http').STATUS_CODES[code] +'\\r\\n');\n  res.write('Connection: close\\r\\n');\n  res.write('Content-Type: application/json\\r\\n');\n  res.write('Content-Length: '+ length +'\\r\\n');\n  res.write('\\r\\n');\n  res.write(message);\n  res.destroy();\n};\n","/home/travis/build/npmtest/node-npmtest-primus/primus/spark.js":"'use strict';\n\nvar ParserError = require('./errors').ParserError\n  , log = require('diagnostics')('primus:spark')\n  , parse = require('querystring').parse\n  , forwarded = require('forwarded-for')\n  , Ultron = require('ultron')\n  , fuse = require('fusing')\n  , yeast = require('yeast')\n  , u2028 = /\\u2028/g\n  , u2029 = /\\u2029/g;\n\n/**\n * The Spark is an indefinable, indescribable energy or soul of a transformer\n * which can be used to create new transformers. In our case, it's a simple\n * wrapping interface.\n *\n * @constructor\n * @param {Primus} primus Reference to the Primus server. (Set using .bind)\n * @param {Object} headers The request headers for this connection.\n * @param {Object} address The object that holds the remoteAddress and port.\n * @param {Object} query The query string of request.\n * @param {String} id An optional id of the socket, or we will generate one.\n * @param {Request} request The HTTP Request instance that initialised the spark.\n * @api public\n */\nfunction Spark(primus, headers, address, query, id, request) {\n  this.fuse();\n\n  var writable = this.writable\n    , spark = this;\n\n  query = query || {};\n  id = id || yeast();\n  headers = headers || {};\n  address = address || {};\n  request = request || headers['primus::req::backup'];\n\n  writable('id', id);                   // Unique id for socket.\n  writable('primus', primus);           // References to Primus.\n  writable('remote', address);          // The remote address location.\n  writable('headers', headers);         // The request headers.\n  writable('request', request);         // Reference to an HTTP request.\n  writable('writable', true);           // Silly stream compatibility.\n  writable('readable', true);           // Silly stream compatibility.\n  writable('queue', []);                // Data queue for data events.\n  writable('query', query);             // The query string.\n  writable('ultron', new Ultron(this)); // Our event listening cleanup.\n  writable('alive', true);              // Flag used to detect zombie sparks.\n\n  //\n  // Parse our query string.\n  //\n  if ('string' === typeof this.query) {\n    this.query = parse(this.query);\n  }\n\n  this.__initialise.forEach(function execute(initialise) {\n    initialise.call(spark);\n  });\n}\n\nfuse(Spark, require('stream'), { merge: false, mixin: false });\n\n//\n// Internal readyState's to prevent writes against close sockets.\n//\nSpark.OPENING = 1;    // Only here for primus.js readyState number compatibility.\nSpark.CLOSED  = 2;    // The connection is closed.\nSpark.OPEN    = 3;    // The connection is open.\n\n//\n// Make sure that we emit `readyState` change events when a new readyState is\n// checked. This way plugins can correctly act according to this.\n//\nSpark.readable('readyState', {\n  get: function get() {\n    return this.__readyState;\n  },\n  set: function set(readyState) {\n    if (this.__readyState === readyState) return readyState;\n\n    this.__readyState = readyState;\n    this.emit('readyStateChange');\n\n    return readyState;\n  }\n}, true);\n\nSpark.writable('__readyState', Spark.OPEN);\n\n//\n// Lazy parse interface for IP address information. As nobody is always\n// interested in this, we're going to defer parsing until it's actually needed.\n//\nSpark.get('address', function address() {\n  return this.request.forwarded || forwarded(this.remote, this.headers, this.primus.whitelist);\n});\n\n/**\n * Checks if the given event is an emitted event by Primus.\n *\n * @param {String} evt The event name.\n * @returns {Boolean}\n * @api public\n */\nSpark.readable('reserved', function reserved(evt) {\n  return (/^(incoming|outgoing)::/).test(evt)\n  || evt in reserved.events;\n});\n\n/**\n * The actual events that are used by the Spark.\n *\n * @type {Object}\n * @api public\n */\nSpark.prototype.reserved.events = {\n  readyStateChange: 1,\n  heartbeat: 1,\n  error: 1,\n  data: 1,\n  end: 1\n};\n\n/**\n * Allows for adding initialise listeners without people overriding our default\n * initializer. If they are feeling adventures and really want want to hack it\n * up, they can remove it from the __initialise array.\n *\n * @returns {Function} The last added initialise hook.\n * @api public\n */\nSpark.readable('initialise', {\n  get: function get() {\n    return this.__initialise[this.__initialise.length - 1];\n  },\n\n  set: function set(initialise) {\n    if ('function' === typeof initialise) this.__initialise.push(initialise);\n  }\n}, true);\n\n/**\n * Send a heartbeat to the client.\n *\n * Checks if any message has been received from the client before sending\n * another heartbeat. If not, we can assume it's dead (no response to our last\n * ping), so we should close.\n *\n * This is intentionally writable so it can be overwritten for custom heartbeat\n * policies.\n *\n * @returns {undefined}\n * @api public\n */\nSpark.writable('heartbeat', function heartbeat() {\n  var spark = this;\n  if (!spark.alive) {\n    //\n    // Set the `reconnect` option to `true` so we don't send a\n    // `primus::server::close` packet to an already broken connection.\n    //\n    spark.end(undefined, { reconnect: true });\n  } else {\n    const now = Date.now();\n\n    spark.alive = false;\n    spark.emit('outgoing::ping', now);\n    spark._write(`primus::ping::${now}`);\n  }\n});\n\n/**\n * Attach hooks and automatically announce a new connection.\n *\n * @type {Array}\n * @api private\n */\nSpark.readable('__initialise', [function initialise() {\n  var primus = this.primus\n    , ultron = this.ultron\n    , spark = this;\n\n  //\n  // Prevent double initialization of the spark. If we already have an\n  // `incoming::data` handler we assume that all other cases are handled as well.\n  //\n  if (this.listeners('incoming::data').length) {\n    return log('already has incoming::data listeners, bailing out');\n  }\n\n  //\n  // We've received new data from our client, decode and emit it.\n  //\n  ultron.on('incoming::data', function message(raw) {\n    primus.decoder.call(spark, raw, function decoding(err, data) {\n      //\n      // Do a \"save\" emit('error') when we fail to parse a message. We don't\n      // want to throw here as listening to errors should be optional.\n      //\n      if (err) {\n        log('failed to decode the incoming data for %s', spark.id);\n        return new ParserError('Failed to decode incoming data: '+ err.message, spark, err);\n      }\n\n      //\n      // Handle \"primus::\" prefixed protocol messages.\n      //\n      if (spark.protocol(data)) return;\n\n      spark.transforms(primus, spark, 'incoming', data, raw);\n    });\n  });\n\n  //\n  // We've received a pong event. This is fired upon receipt of a\n  // `pimus::pong::<timestamp>` message.\n  //\n  ultron.on('incoming::pong', function pong() {\n    spark.alive = true;\n    spark.emit('heartbeat');\n  });\n\n  //\n  // The client has disconnected.\n  //\n  ultron.on('incoming::end', function disconnect() {\n    //\n    // The socket is closed, sending data over it will throw an error.\n    //\n    log('transformer closed connection for %s', spark.id);\n    spark.end(undefined, { reconnect: true });\n  });\n\n  ultron.on('incoming::error', function error(err) {\n    //\n    // Ensure that the error we emit is always an Error instance. There are\n    // transformers that used to emit only strings. A string is not an Error.\n    //\n    if ('string' === typeof err) {\n      err = new Error(err);\n    }\n\n    if (spark.listeners('error').length) spark.emit('error', err);\n    spark.primus.emit('log', 'error', err);\n\n    log('transformer received error `%s` for %s', err.message, spark.id);\n    spark.end();\n  });\n\n  //\n  // End is triggered by both incoming and outgoing events.\n  //\n  ultron.on('end', function end() {\n    primus.emit('disconnection', spark);\n  });\n\n  //\n  // Announce a new connection. This allows the transformers to change or listen\n  // to events before we announce it.\n  //\n  process.nextTick(function tick() {\n    primus.asyncemit('connection', spark, function damn(err) {\n      if (!err) {\n        if (spark.queue) spark.queue.forEach(function each(packet) {\n          spark.emit('data', packet.data, packet.raw);\n        });\n\n        spark.queue = null;\n        return;\n      }\n\n      spark.emit('incoming::error', err);\n    });\n  });\n}]);\n\n/**\n * Execute the set of message transformers from Primus on the incoming or\n * outgoing message.\n * This function and it's content should be in sync with Primus#transforms in\n * primus.js.\n *\n * @param {Primus} primus Reference to the Primus instance with message transformers.\n * @param {Spark|Primus} connection Connection that receives or sends data.\n * @param {String} type The type of message, 'incoming' or 'outgoing'.\n * @param {Mixed} data The data to send or that has been received.\n * @param {String} raw The raw encoded data.\n * @returns {Spark}\n * @api public\n */\nSpark.readable('transforms', function transforms(primus, connection, type, data, raw) {\n  var packet = { data: data, raw: raw }\n    , fns = primus.transformers[type];\n\n  //\n  // Iterate in series over the message transformers so we can allow optional\n  // asynchronous execution of message transformers which could for example\n  // retrieve additional data from the server, do extra decoding or even\n  // message validation.\n  //\n  (function transform(index, done) {\n    var transformer = fns[index++];\n\n    if (!transformer) return done();\n\n    if (1 === transformer.length) {\n      if (false === transformer.call(connection, packet)) {\n        //\n        // When false is returned by an incoming transformer it means that's\n        // being handled by the transformer and we should not emit the `data`\n        // event.\n        //\n        return;\n      }\n\n      return transform(index, done);\n    }\n\n    transformer.call(connection, packet, function finished(err, arg) {\n      if (err) return connection.emit('error', err);\n      if (false === arg) return;\n\n      transform(index, done);\n    });\n  }(0, function done() {\n    //\n    // We always emit 2 arguments for the data event, the first argument is the\n    // parsed data and the second argument is the raw string that we received.\n    // This allows you, for example, to do some validation on the parsed data\n    // and then save the raw string in your database without the stringify\n    // overhead.\n    //\n    if ('incoming' === type) {\n      //\n      // This is pretty bad edge case, it's possible that the async version of\n      // the `connection` event listener takes so long that we cannot assign\n      // `data` handlers and we are already receiving data as the connection is\n      // already established. In this edge case we need to queue the data and\n      // pass it to the data event once we're listening.\n      //\n      if (connection.queue) return connection.queue.push(packet);\n      return connection.emit('data', packet.data, packet.raw);\n    }\n\n    connection._write(packet.data);\n  }));\n\n  return this;\n});\n\n/**\n * Really dead simple protocol parser. We simply assume that every message that\n * is prefixed with `primus::` could be used as some sort of protocol definition\n * for Primus.\n *\n * @param {String} msg The data.\n * @returns {Boolean} Is a protocol message.\n * @api private\n */\nSpark.readable('protocol', function protocol(msg) {\n  if (\n       'string' !== typeof msg\n    || msg.indexOf('primus::') !== 0\n  ) return false;\n\n  var last = msg.indexOf(':', 8)\n    , value = msg.slice(last + 2);\n\n  switch (msg.slice(8,  last)) {\n    case 'pong':\n      this.emit('incoming::pong', +value);\n      break;\n\n    case 'id':\n      this._write('primus::id::'+ this.id);\n      break;\n\n    //\n    // Unknown protocol, somebody is probably sending `primus::` prefixed\n    // messages.\n    //\n    default:\n      log('message `%s` was prefixed with primus:: but not supported', msg);\n      return false;\n  }\n\n  log('processed a primus protocol message `%s`', msg);\n  return true;\n});\n\n/**\n * Send a new message to a given spark.\n *\n * @param {Mixed} data The data that needs to be written.\n * @returns {Boolean} Always returns true.\n * @api public\n */\nSpark.readable('write', function write(data) {\n  var primus = this.primus;\n\n  //\n  // The connection is closed, return false.\n  //\n  if (Spark.CLOSED === this.readyState) {\n    log('attempted to write but readyState was already set to CLOSED for %s', this.id);\n    return false;\n  }\n\n  this.transforms(primus, this, 'outgoing', data);\n\n  return true;\n});\n\n/**\n * The actual message writer.\n *\n * @param {Mixed} data The message that needs to be written.\n * @returns {Boolean}\n * @api private\n */\nSpark.readable('_write', function _write(data) {\n  var primus = this.primus\n    , spark = this;\n\n  //\n  // The connection is closed, normally this would already be done in the\n  // `spark.write` method, but as `_write` is used internally, we should also\n  // add the same check here to prevent potential crashes by writing to a dead\n  // socket.\n  //\n  if (Spark.CLOSED === spark.readyState) {\n    log('attempted to _write but readyState was already set to CLOSED for %s', spark.id);\n    return false;\n  }\n\n  primus.encoder.call(spark, data, function encoded(err, packet) {\n    //\n    // Do a \"safe\" emit('error') when we fail to parse a message. We don't\n    // want to throw here as listening to errors should be optional.\n    //\n    if (err) return new ParserError('Failed to encode outgoing data: '+ err.message, spark, err);\n    if (!packet) return log('nothing to write, bailing out for %s', spark.id);\n\n    //\n    // Hack 1: \\u2028 and \\u2029 are allowed inside a JSON string, but JavaScript\n    // defines them as newline separators. Unescaped control characters are not\n    // allowed inside JSON strings, so this causes an error at parse time. We\n    // work around this issue by escaping these characters. This can cause\n    // errors with JSONP requests or if the string is just evaluated.\n    //\n    if ('string' === typeof packet) {\n      if (~packet.indexOf('\\u2028')) packet = packet.replace(u2028, '\\\\u2028');\n      if (~packet.indexOf('\\u2029')) packet = packet.replace(u2029, '\\\\u2029');\n    }\n\n    spark.emit('outgoing::data', packet);\n  });\n\n  return true;\n});\n\n/**\n * End the connection.\n *\n * Options:\n * - reconnect (boolean) Trigger client-side reconnect.\n *\n * @param {Mixed} data Optional closing data.\n * @param {Object} options End instructions.\n * @api public\n */\nSpark.readable('end', function end(data, options) {\n  if (Spark.CLOSED === this.readyState) return this;\n\n  options = options || {};\n  if (data !== undefined) this.write(data);\n\n  //\n  // If we want to trigger a reconnect do not send\n  // `primus::server::close`, otherwise bypass the .write method\n  // as this message should not be transformed.\n  //\n  if (!options.reconnect) this._write('primus::server::close');\n\n  //\n  // This seems redundant but there are cases where the above writes\n  // can trigger another `end` call. An example is with Engine.IO\n  // when calling `end` on the client and `end` on the spark right\n  // after. The `end` call on the spark comes before the `incoming::end`\n  // event and the result is an attempt of writing to a closed socket.\n  // When this happens Engine.IO closes the connection and without\n  // this check the following instructions could be executed twice.\n  //\n  if (Spark.CLOSED === this.readyState) return this;\n\n  log('emitting final events for spark %s', this.id);\n\n  this.readyState = Spark.CLOSED;\n  this.emit('outgoing::end');\n  this.emit('end');\n  this.ultron.destroy();\n  this.ultron = this.queue = null;\n\n  return this;\n});\n\n//\n// Expose the module.\n//\nmodule.exports = Spark;\n"}